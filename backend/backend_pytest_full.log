EEEEEEEEEEEEEEEEEEEEEEEssEEEEEEEEEEEEEEEEEE                              [100%]
==================================== ERRORS ====================================
__________________ ERROR at setup of test_post_concierge_plan __________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
____________________ ERROR at setup of test_plan_request_ok ____________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_______________ ERROR at setup of test_place_lite_location_typed _______________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_______________ ERROR at setup of test_build_plan_rank_and_mode ________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_________________ ERROR at setup of test_build_plan_no_results _________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
____________________ ERROR at setup of test_shrines_list_ok ____________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_________________ ERROR at setup of test_goriyaku_tags_list_ok _________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
___________ ERROR at setup of test_concierge_recommendations_relaxed ___________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
___________________ ERROR at setup of test_shorten_examples ____________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_________ ERROR at setup of test_fill_locations_backfills_and_shortens _________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_ ERROR at setup of test_fill_locations_prefers_candidate_address_without_requests _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_______________ ERROR at setup of test_api_radius_km_5km_passed ________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_________ ERROR at setup of test_api_accepts_area_string_and_shortens __________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
__________ ERROR at setup of test_api_radius_clip_to_50km_and_passed ___________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_____________ ERROR at setup of test_chat_backfills_short_location _____________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
______________ ERROR at setup of test_radius_km_bias_passthrough _______________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
__________ ERROR at setup of test_candidate_formatted_address_is_used __________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
______________ ERROR at setup of test_concierge_chat_returns_200 _______________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_______________ ERROR at setup of test_favorites_crud_happy_path _______________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_______________ ERROR at setup of test_favorites_are_user_scoped _______________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
__________________ ERROR at setup of test_post_is_idempotent ___________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_____ ERROR at setup of ShrinePermissionTests.test_non_owner_cannot_route ______

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
__ ERROR at setup of ShrinePermissionTests.test_non_owner_cannot_view_detail ___

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_________________ ERROR at setup of test_text_search_is_cached _________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
____________________ ERROR at setup of test_photo_is_cached ____________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
________________ ERROR at setup of test_nearby_search_throttled ________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
___________________ ERROR at setup of test_popular_ordering ____________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
___________________ ERROR at setup of test_near_filter_bbox ____________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
______ ERROR at setup of test_recommend_shrines_applies_bonus_and_orders _______

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
____________ ERROR at setup of test_recommend_shrines_disable_bonus ____________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_____________________ ERROR at setup of test_route_api_ok ______________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
____________ ERROR at setup of test_route_api_requires_destinations ____________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
______________ ERROR at setup of test_route_api_max_destinations _______________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
______ ERROR at setup of test_route_api_latlng_range_validation[origin0] _______

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
______ ERROR at setup of test_route_api_latlng_range_validation[origin1] _______

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_____ ERROR at setup of test_build_route_returns_legs_and_totals[walking] ______

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_____ ERROR at setup of test_build_route_returns_legs_and_totals[driving] ______

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
___ ERROR at setup of RouteViewTests.test_requires_login_redirects_to_login ____

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_ ERROR at setup of RouteViewTests.test_route_page_renders_with_script_and_map_div _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_____________________ ERROR at setup of test_resolve_names _____________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
_____________________ ERROR at setup of test_reverse_paths _____________________

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
>           return self.fields_map[field_name]
E           KeyError: 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:683: KeyError

During handling of the above exception, another exception occurred:

request = <SubRequest 'django_db_setup' for <Function test_post_concierge_plan>>
django_test_environment = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x102d730e0>
django_db_use_migrations = True, django_db_keepdb = True
django_db_createdb = True, django_db_modify_db_settings = None

    @pytest.fixture(scope="session")
    def django_db_setup(
        request: pytest.FixtureRequest,
        django_test_environment: None,
        django_db_blocker: DjangoDbBlocker,
        django_db_use_migrations: bool,
        django_db_keepdb: bool,
        django_db_createdb: bool,
        django_db_modify_db_settings: None,
    ) -> Generator[None, None, None]:
        """Top level fixture to ensure test databases are available"""
        from django.test.utils import setup_databases, teardown_databases

        setup_databases_args = {}

        if not django_db_use_migrations:
            _disable_migrations()

        if django_db_keepdb and not django_db_createdb:
            setup_databases_args["keepdb"] = True

        with django_db_blocker.unblock():
>           db_cfg = setup_databases(
                verbosity=request.config.option.verbose,
                interactive=False,
                **setup_databases_args,
            )

.venv/lib/python3.13/site-packages/pytest_django/fixtures.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/django/test/utils.py:204: in setup_databases
    connection.creation.create_test_db(
.venv/lib/python3.13/site-packages/django/db/backends/base/creation.py:78: in create_test_db
    call_command(
.venv/lib/python3.13/site-packages/django/core/management/__init__.py:194: in call_command
    return command.execute(*args, **defaults)
.venv/lib/python3.13/site-packages/django/core/management/base.py:460: in execute
    output = self.handle(*args, **options)
.venv/lib/python3.13/site-packages/django/core/management/base.py:107: in wrapper
    res = handle_func(*args, **kwargs)
.venv/lib/python3.13/site-packages/django/core/management/commands/migrate.py:353: in handle
    post_migrate_state = executor.migrate(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:135: in migrate
    state = self._migrate_all_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:167: in _migrate_all_forwards
    state = self.apply_migration(
.venv/lib/python3.13/site-packages/django/db/migrations/executor.py:255: in apply_migration
    state = migration.apply(state, schema_editor)
.venv/lib/python3.13/site-packages/django/db/migrations/migration.py:132: in apply
    operation.database_forwards(
.venv/lib/python3.13/site-packages/django/db/migrations/operations/models.py:954: in database_forwards
    schema_editor.add_index(model, self.index)
.venv/lib/python3.13/site-packages/django/db/backends/base/schema.py:569: in add_index
    self.execute(index.create_sql(model, self), params=None)
.venv/lib/python3.13/site-packages/django/contrib/postgres/indexes.py:26: in create_sql
    statement = super().create_sql(
.venv/lib/python3.13/site-packages/django/db/models/indexes.py:112: in create_sql
    model._meta.get_field(field_name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Options for Shrine>, field_name = 'location'

    def get_field(self, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        try:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            return self._forward_fields_map[field_name]
        except KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            if not self.apps.models_ready:
                raise FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so if this is an auto-created related field, it won't "
                    "be available yet." % (self.object_name, field_name)
                )

        try:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            return self.fields_map[field_name]
        except KeyError:
>           raise FieldDoesNotExist(
                "%s has no field named '%s'" % (self.object_name, field_name)
            )
E           django.core.exceptions.FieldDoesNotExist: Shrine has no field named 'location'

.venv/lib/python3.13/site-packages/django/db/models/options.py:685: FieldDoesNotExist
=========================== short test summary info ============================
ERROR temples/tests/api/test_concierge_plan_api.py::test_post_concierge_plan
ERROR temples/tests/serializers/test_concierge_serializers.py::test_plan_request_ok
ERROR temples/tests/serializers/test_concierge_serializers.py::test_place_lite_location_typed
ERROR temples/tests/services/test_concierge_service.py::test_build_plan_rank_and_mode
ERROR temples/tests/services/test_concierge_service.py::test_build_plan_no_results
ERROR temples/tests/test_api_basic.py::test_shrines_list_ok - django.core.exc...
ERROR temples/tests/test_api_basic.py::test_goriyaku_tags_list_ok - django.co...
ERROR temples/tests/test_api_basic.py::test_concierge_recommendations_relaxed
ERROR temples/tests/test_concierge.py::test_shorten_examples - django.core.ex...
ERROR temples/tests/test_concierge.py::test_fill_locations_backfills_and_shortens
ERROR temples/tests/test_concierge.py::test_fill_locations_prefers_candidate_address_without_requests
ERROR temples/tests/test_concierge.py::test_api_radius_km_5km_passed - django...
ERROR temples/tests/test_concierge.py::test_api_accepts_area_string_and_shortens
ERROR temples/tests/test_concierge.py::test_api_radius_clip_to_50km_and_passed
ERROR temples/tests/test_concierge_api.py::test_chat_backfills_short_location
ERROR temples/tests/test_concierge_api.py::test_radius_km_bias_passthrough - ...
ERROR temples/tests/test_concierge_api.py::test_candidate_formatted_address_is_used
ERROR temples/tests/test_concierge_chat.py::test_concierge_chat_returns_200
ERROR temples/tests/test_favorites_api.py::test_favorites_crud_happy_path - d...
ERROR temples/tests/test_favorites_api.py::test_favorites_are_user_scoped - d...
ERROR temples/tests/test_favorites_api_idempotency.py::test_post_is_idempotent
ERROR temples/tests/test_permissions.py::ShrinePermissionTests::test_non_owner_cannot_route
ERROR temples/tests/test_permissions.py::ShrinePermissionTests::test_non_owner_cannot_view_detail
ERROR temples/tests/test_places_cache_and_throttle.py::test_text_search_is_cached
ERROR temples/tests/test_places_cache_and_throttle.py::test_photo_is_cached
ERROR temples/tests/test_places_cache_and_throttle.py::test_nearby_search_throttled
ERROR temples/tests/test_popular_api.py::test_popular_ordering - django.core....
ERROR temples/tests/test_popular_api.py::test_near_filter_bbox - django.core....
ERROR temples/tests/test_recommendation_adapter.py::test_recommend_shrines_applies_bonus_and_orders
ERROR temples/tests/test_recommendation_adapter.py::test_recommend_shrines_disable_bonus
ERROR temples/tests/test_route_api.py::test_route_api_ok - django.core.except...
ERROR temples/tests/test_route_api.py::test_route_api_requires_destinations
ERROR temples/tests/test_route_api.py::test_route_api_max_destinations - djan...
ERROR temples/tests/test_route_api.py::test_route_api_latlng_range_validation[origin0]
ERROR temples/tests/test_route_api.py::test_route_api_latlng_range_validation[origin1]
ERROR temples/tests/test_route_service.py::test_build_route_returns_legs_and_totals[walking]
ERROR temples/tests/test_route_service.py::test_build_route_returns_legs_and_totals[driving]
ERROR temples/tests/test_route_view.py::RouteViewTests::test_requires_login_redirects_to_login
ERROR temples/tests/test_route_view.py::RouteViewTests::test_route_page_renders_with_script_and_map_div
ERROR temples/tests/test_urls.py::test_resolve_names - django.core.exceptions...
ERROR temples/tests/test_urls.py::test_reverse_paths - django.core.exceptions...
